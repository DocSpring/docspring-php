<?php
/**
 * Client
 * PHP version 8.1
 *
 * @category Class
 * @package  DocSpring
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * DocSpring API
 *
 * Use DocSpring's API to programmatically fill out PDF forms, convert HTML to PDFs, merge PDFs, or request legally binding e-signatures.
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.16.0-DOCSPRING
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace DocSpring\Api;

use GuzzleHttp\Client as GuzzleHttpClient;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use DocSpring\ApiException;
use DocSpring\Configuration;
use DocSpring\FormDataProcessor;
use DocSpring\HeaderSelector;
use DocSpring\ObjectSerializer;

/**
 * Client Class Doc Comment
 *
 * @category Class
 * @package  DocSpring
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Client
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addFieldsToTemplate' => [
            'application/json',
        ],
        'batchGeneratePdfs' => [
            'application/json',
        ],
        'combinePdfs' => [
            'application/json',
        ],
        'copyTemplate' => [
            'application/json',
        ],
        'createCustomFileFromUpload' => [
            'application/json',
        ],
        'createDataRequestEvent' => [
            'application/json',
        ],
        'createDataRequestToken' => [
            'application/json',
        ],
        'createFolder' => [
            'application/json',
        ],
        'createHtmlTemplate' => [
            'application/json',
        ],
        'createPdfTemplate' => [
            'multipart/form-data',
        ],
        'createPdfTemplateFromUpload' => [
            'application/json',
        ],
        'deleteFolder' => [
            'application/json',
        ],
        'deleteTemplate' => [
            'application/json',
        ],
        'expireCombinedSubmission' => [
            'application/json',
        ],
        'expireSubmission' => [
            'application/json',
        ],
        'generatePdf' => [
            'application/json',
        ],
        'generatePreview' => [
            'application/json',
        ],
        'getCombinedSubmission' => [
            'application/json',
        ],
        'getDataRequest' => [
            'application/json',
        ],
        'getFullTemplate' => [
            'application/json',
        ],
        'getPresignUrl' => [
            'application/json',
        ],
        'getSubmission' => [
            'application/json',
        ],
        'getSubmissionBatch' => [
            'application/json',
        ],
        'getTemplate' => [
            'application/json',
        ],
        'getTemplateSchema' => [
            'application/json',
        ],
        'listCombinedSubmissions' => [
            'application/json',
        ],
        'listFolders' => [
            'application/json',
        ],
        'listSubmissions' => [
            'application/json',
        ],
        'listTemplateSubmissions' => [
            'application/json',
        ],
        'listTemplates' => [
            'application/json',
        ],
        'moveFolderToFolder' => [
            'application/json',
        ],
        'moveTemplateToFolder' => [
            'application/json',
        ],
        'publishTemplateVersion' => [
            'application/json',
        ],
        'renameFolder' => [
            'application/json',
        ],
        'restoreTemplateVersion' => [
            'application/json',
        ],
        'testAuthentication' => [
            'application/json',
        ],
        'updateDataRequest' => [
            'application/json',
        ],
        'updateTemplate' => [
            'application/json',
        ],
        'updateTemplateDocument' => [
            'multipart/form-data',
        ],
        'updateTemplateDocumentFromUpload' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new GuzzleHttpClient();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addFieldsToTemplate
     *
     * Add new fields to a Template
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\AddFieldsData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFieldsToTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplateAddFieldsResponse|\DocSpring\Model\TemplateAddFieldsResponse
     */
    public function addFieldsToTemplate($template_id, $data, string $contentType = self::contentTypes['addFieldsToTemplate'][0])
    {
        list($response) = $this->addFieldsToTemplateWithHttpInfo($template_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation addFieldsToTemplateWithHttpInfo
     *
     * Add new fields to a Template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\AddFieldsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFieldsToTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplateAddFieldsResponse|\DocSpring\Model\TemplateAddFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFieldsToTemplateWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['addFieldsToTemplate'][0])
    {
        $request = $this->addFieldsToTemplateRequest($template_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplateAddFieldsResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplateAddFieldsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplateAddFieldsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplateAddFieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplateAddFieldsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addFieldsToTemplateAsync
     *
     * Add new fields to a Template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\AddFieldsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFieldsToTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFieldsToTemplateAsync($template_id, $data, string $contentType = self::contentTypes['addFieldsToTemplate'][0])
    {
        return $this->addFieldsToTemplateAsyncWithHttpInfo($template_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFieldsToTemplateAsyncWithHttpInfo
     *
     * Add new fields to a Template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\AddFieldsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFieldsToTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFieldsToTemplateAsyncWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['addFieldsToTemplate'][0])
    {
        $returnType = '\DocSpring\Model\TemplateAddFieldsResponse';
        $request = $this->addFieldsToTemplateRequest($template_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFieldsToTemplate'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\AddFieldsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFieldsToTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addFieldsToTemplateRequest($template_id, $data, string $contentType = self::contentTypes['addFieldsToTemplate'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling addFieldsToTemplate'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling addFieldsToTemplate'
            );
        }


        $resourcePath = '/templates/{template_id}/add_fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation batchGeneratePdfs
     *
     * Generate multiple PDFs
     *
     * @param  \DocSpring\Model\SubmissionBatchData $data data (required)
     * @param  bool|null $wait Wait for submission batch to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchGeneratePdfs'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\BatchGeneratePdfs201Response|\DocSpring\Model\BatchGeneratePdfs201Response|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorOrMultipleErrorsResponse|\DocSpring\Model\ErrorResponse
     */
    public function batchGeneratePdfs($data, $wait = true, string $contentType = self::contentTypes['batchGeneratePdfs'][0])
    {
        list($response) = $this->batchGeneratePdfsWithHttpInfo($data, $wait, $contentType);
        return $response;
    }

    /**
     * Operation batchGeneratePdfsWithHttpInfo
     *
     * Generate multiple PDFs
     *
     * @param  \DocSpring\Model\SubmissionBatchData $data (required)
     * @param  bool|null $wait Wait for submission batch to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchGeneratePdfs'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\BatchGeneratePdfs201Response|\DocSpring\Model\BatchGeneratePdfs201Response|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorOrMultipleErrorsResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchGeneratePdfsWithHttpInfo($data, $wait = true, string $contentType = self::contentTypes['batchGeneratePdfs'][0])
    {
        $request = $this->batchGeneratePdfsRequest($data, $wait, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\BatchGeneratePdfs201Response',
                        $request,
                        $response,
                    );
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\BatchGeneratePdfs201Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorOrMultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\BatchGeneratePdfs201Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\BatchGeneratePdfs201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\BatchGeneratePdfs201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorOrMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation batchGeneratePdfsAsync
     *
     * Generate multiple PDFs
     *
     * @param  \DocSpring\Model\SubmissionBatchData $data (required)
     * @param  bool|null $wait Wait for submission batch to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchGeneratePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchGeneratePdfsAsync($data, $wait = true, string $contentType = self::contentTypes['batchGeneratePdfs'][0])
    {
        return $this->batchGeneratePdfsAsyncWithHttpInfo($data, $wait, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchGeneratePdfsAsyncWithHttpInfo
     *
     * Generate multiple PDFs
     *
     * @param  \DocSpring\Model\SubmissionBatchData $data (required)
     * @param  bool|null $wait Wait for submission batch to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchGeneratePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchGeneratePdfsAsyncWithHttpInfo($data, $wait = true, string $contentType = self::contentTypes['batchGeneratePdfs'][0])
    {
        $returnType = '\DocSpring\Model\BatchGeneratePdfs201Response';
        $request = $this->batchGeneratePdfsRequest($data, $wait, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchGeneratePdfs'
     *
     * @param  \DocSpring\Model\SubmissionBatchData $data (required)
     * @param  bool|null $wait Wait for submission batch to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchGeneratePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchGeneratePdfsRequest($data, $wait = true, string $contentType = self::contentTypes['batchGeneratePdfs'][0])
    {

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling batchGeneratePdfs'
            );
        }



        $resourcePath = '/submissions/batches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wait,
            'wait', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation combinePdfs
     *
     * Merge submission PDFs, template PDFs, or custom files
     *
     * @param  \DocSpring\Model\CombinePdfsData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combinePdfs'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CreateCombinedSubmissionResponse|\DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function combinePdfs($data, string $contentType = self::contentTypes['combinePdfs'][0])
    {
        list($response) = $this->combinePdfsWithHttpInfo($data, $contentType);
        return $response;
    }

    /**
     * Operation combinePdfsWithHttpInfo
     *
     * Merge submission PDFs, template PDFs, or custom files
     *
     * @param  \DocSpring\Model\CombinePdfsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combinePdfs'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CreateCombinedSubmissionResponse|\DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function combinePdfsWithHttpInfo($data, string $contentType = self::contentTypes['combinePdfs'][0])
    {
        $request = $this->combinePdfsRequest($data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CreateCombinedSubmissionResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CreateCombinedSubmissionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CreateCombinedSubmissionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation combinePdfsAsync
     *
     * Merge submission PDFs, template PDFs, or custom files
     *
     * @param  \DocSpring\Model\CombinePdfsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combinePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function combinePdfsAsync($data, string $contentType = self::contentTypes['combinePdfs'][0])
    {
        return $this->combinePdfsAsyncWithHttpInfo($data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation combinePdfsAsyncWithHttpInfo
     *
     * Merge submission PDFs, template PDFs, or custom files
     *
     * @param  \DocSpring\Model\CombinePdfsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combinePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function combinePdfsAsyncWithHttpInfo($data, string $contentType = self::contentTypes['combinePdfs'][0])
    {
        $returnType = '\DocSpring\Model\CreateCombinedSubmissionResponse';
        $request = $this->combinePdfsRequest($data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'combinePdfs'
     *
     * @param  \DocSpring\Model\CombinePdfsData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combinePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function combinePdfsRequest($data, string $contentType = self::contentTypes['combinePdfs'][0])
    {

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling combinePdfs'
            );
        }


        $resourcePath = '/combined_submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyTemplate
     *
     * Copy a template
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\CopyTemplateOptions|null $options options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse
     */
    public function copyTemplate($template_id, $options = null, string $contentType = self::contentTypes['copyTemplate'][0])
    {
        list($response) = $this->copyTemplateWithHttpInfo($template_id, $options, $contentType);
        return $response;
    }

    /**
     * Operation copyTemplateWithHttpInfo
     *
     * Copy a template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CopyTemplateOptions|null $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyTemplateWithHttpInfo($template_id, $options = null, string $contentType = self::contentTypes['copyTemplate'][0])
    {
        $request = $this->copyTemplateRequest($template_id, $options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation copyTemplateAsync
     *
     * Copy a template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CopyTemplateOptions|null $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyTemplateAsync($template_id, $options = null, string $contentType = self::contentTypes['copyTemplate'][0])
    {
        return $this->copyTemplateAsyncWithHttpInfo($template_id, $options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyTemplateAsyncWithHttpInfo
     *
     * Copy a template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CopyTemplateOptions|null $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyTemplateAsyncWithHttpInfo($template_id, $options = null, string $contentType = self::contentTypes['copyTemplate'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview';
        $request = $this->copyTemplateRequest($template_id, $options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyTemplate'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CopyTemplateOptions|null $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function copyTemplateRequest($template_id, $options = null, string $contentType = self::contentTypes['copyTemplate'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling copyTemplate'
            );
        }



        $resourcePath = '/templates/{template_id}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($options));
            } else {
                $httpBody = $options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCustomFileFromUpload
     *
     * Create a new custom file from a cached S3 upload
     *
     * @param  \DocSpring\Model\CreateCustomFileData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomFileFromUpload'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CreateCustomFileResponse|\DocSpring\Model\ErrorResponse
     */
    public function createCustomFileFromUpload($data, string $contentType = self::contentTypes['createCustomFileFromUpload'][0])
    {
        list($response) = $this->createCustomFileFromUploadWithHttpInfo($data, $contentType);
        return $response;
    }

    /**
     * Operation createCustomFileFromUploadWithHttpInfo
     *
     * Create a new custom file from a cached S3 upload
     *
     * @param  \DocSpring\Model\CreateCustomFileData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomFileFromUpload'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CreateCustomFileResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCustomFileFromUploadWithHttpInfo($data, string $contentType = self::contentTypes['createCustomFileFromUpload'][0])
    {
        $request = $this->createCustomFileFromUploadRequest($data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CreateCustomFileResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CreateCustomFileResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CreateCustomFileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCustomFileFromUploadAsync
     *
     * Create a new custom file from a cached S3 upload
     *
     * @param  \DocSpring\Model\CreateCustomFileData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomFileFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomFileFromUploadAsync($data, string $contentType = self::contentTypes['createCustomFileFromUpload'][0])
    {
        return $this->createCustomFileFromUploadAsyncWithHttpInfo($data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCustomFileFromUploadAsyncWithHttpInfo
     *
     * Create a new custom file from a cached S3 upload
     *
     * @param  \DocSpring\Model\CreateCustomFileData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomFileFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomFileFromUploadAsyncWithHttpInfo($data, string $contentType = self::contentTypes['createCustomFileFromUpload'][0])
    {
        $returnType = '\DocSpring\Model\CreateCustomFileResponse';
        $request = $this->createCustomFileFromUploadRequest($data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCustomFileFromUpload'
     *
     * @param  \DocSpring\Model\CreateCustomFileData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomFileFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCustomFileFromUploadRequest($data, string $contentType = self::contentTypes['createCustomFileFromUpload'][0])
    {

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createCustomFileFromUpload'
            );
        }


        $resourcePath = '/custom_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDataRequestEvent
     *
     * Create a new event for emailing a signee a request for signature
     *
     * @param  string $data_request_id data_request_id (required)
     * @param  \DocSpring\Model\CreateSubmissionDataRequestEventRequest $event event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestEvent'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CreateSubmissionDataRequestEventResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\MultipleErrorsResponse
     */
    public function createDataRequestEvent($data_request_id, $event, string $contentType = self::contentTypes['createDataRequestEvent'][0])
    {
        list($response) = $this->createDataRequestEventWithHttpInfo($data_request_id, $event, $contentType);
        return $response;
    }

    /**
     * Operation createDataRequestEventWithHttpInfo
     *
     * Create a new event for emailing a signee a request for signature
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\CreateSubmissionDataRequestEventRequest $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestEvent'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CreateSubmissionDataRequestEventResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\MultipleErrorsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDataRequestEventWithHttpInfo($data_request_id, $event, string $contentType = self::contentTypes['createDataRequestEvent'][0])
    {
        $request = $this->createDataRequestEventRequest($data_request_id, $event, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CreateSubmissionDataRequestEventResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CreateSubmissionDataRequestEventResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CreateSubmissionDataRequestEventResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDataRequestEventAsync
     *
     * Create a new event for emailing a signee a request for signature
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\CreateSubmissionDataRequestEventRequest $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDataRequestEventAsync($data_request_id, $event, string $contentType = self::contentTypes['createDataRequestEvent'][0])
    {
        return $this->createDataRequestEventAsyncWithHttpInfo($data_request_id, $event, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDataRequestEventAsyncWithHttpInfo
     *
     * Create a new event for emailing a signee a request for signature
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\CreateSubmissionDataRequestEventRequest $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDataRequestEventAsyncWithHttpInfo($data_request_id, $event, string $contentType = self::contentTypes['createDataRequestEvent'][0])
    {
        $returnType = '\DocSpring\Model\CreateSubmissionDataRequestEventResponse';
        $request = $this->createDataRequestEventRequest($data_request_id, $event, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDataRequestEvent'
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\CreateSubmissionDataRequestEventRequest $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDataRequestEventRequest($data_request_id, $event, string $contentType = self::contentTypes['createDataRequestEvent'][0])
    {

        // verify the required parameter 'data_request_id' is set
        if ($data_request_id === null || (is_array($data_request_id) && count($data_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data_request_id when calling createDataRequestEvent'
            );
        }

        // verify the required parameter 'event' is set
        if ($event === null || (is_array($event) && count($event) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event when calling createDataRequestEvent'
            );
        }


        $resourcePath = '/data_requests/{data_request_id}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($data_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'data_request_id' . '}',
                ObjectSerializer::toPathValue($data_request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($event)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($event));
            } else {
                $httpBody = $event;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDataRequestToken
     *
     * Create a new data request token for form authentication
     *
     * @param  string $data_request_id data_request_id (required)
     * @param  string|null $type type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestToken'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CreateSubmissionDataRequestTokenResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function createDataRequestToken($data_request_id, $type = null, string $contentType = self::contentTypes['createDataRequestToken'][0])
    {
        list($response) = $this->createDataRequestTokenWithHttpInfo($data_request_id, $type, $contentType);
        return $response;
    }

    /**
     * Operation createDataRequestTokenWithHttpInfo
     *
     * Create a new data request token for form authentication
     *
     * @param  string $data_request_id (required)
     * @param  string|null $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestToken'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CreateSubmissionDataRequestTokenResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDataRequestTokenWithHttpInfo($data_request_id, $type = null, string $contentType = self::contentTypes['createDataRequestToken'][0])
    {
        $request = $this->createDataRequestTokenRequest($data_request_id, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CreateSubmissionDataRequestTokenResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CreateSubmissionDataRequestTokenResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CreateSubmissionDataRequestTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createDataRequestTokenAsync
     *
     * Create a new data request token for form authentication
     *
     * @param  string $data_request_id (required)
     * @param  string|null $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDataRequestTokenAsync($data_request_id, $type = null, string $contentType = self::contentTypes['createDataRequestToken'][0])
    {
        return $this->createDataRequestTokenAsyncWithHttpInfo($data_request_id, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDataRequestTokenAsyncWithHttpInfo
     *
     * Create a new data request token for form authentication
     *
     * @param  string $data_request_id (required)
     * @param  string|null $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDataRequestTokenAsyncWithHttpInfo($data_request_id, $type = null, string $contentType = self::contentTypes['createDataRequestToken'][0])
    {
        $returnType = '\DocSpring\Model\CreateSubmissionDataRequestTokenResponse';
        $request = $this->createDataRequestTokenRequest($data_request_id, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDataRequestToken'
     *
     * @param  string $data_request_id (required)
     * @param  string|null $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDataRequestToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDataRequestTokenRequest($data_request_id, $type = null, string $contentType = self::contentTypes['createDataRequestToken'][0])
    {

        // verify the required parameter 'data_request_id' is set
        if ($data_request_id === null || (is_array($data_request_id) && count($data_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data_request_id when calling createDataRequestToken'
            );
        }



        $resourcePath = '/data_requests/{data_request_id}/tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($data_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'data_request_id' . '}',
                ObjectSerializer::toPathValue($data_request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFolder
     *
     * Create a folder
     *
     * @param  \DocSpring\Model\CreateFolderData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse
     */
    public function createFolder($data, string $contentType = self::contentTypes['createFolder'][0])
    {
        list($response) = $this->createFolderWithHttpInfo($data, $contentType);
        return $response;
    }

    /**
     * Operation createFolderWithHttpInfo
     *
     * Create a folder
     *
     * @param  \DocSpring\Model\CreateFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFolderWithHttpInfo($data, string $contentType = self::contentTypes['createFolder'][0])
    {
        $request = $this->createFolderRequest($data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Folder',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Folder',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFolderAsync
     *
     * Create a folder
     *
     * @param  \DocSpring\Model\CreateFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsync($data, string $contentType = self::contentTypes['createFolder'][0])
    {
        return $this->createFolderAsyncWithHttpInfo($data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFolderAsyncWithHttpInfo
     *
     * Create a folder
     *
     * @param  \DocSpring\Model\CreateFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsyncWithHttpInfo($data, string $contentType = self::contentTypes['createFolder'][0])
    {
        $returnType = '\DocSpring\Model\Folder';
        $request = $this->createFolderRequest($data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFolder'
     *
     * @param  \DocSpring\Model\CreateFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFolderRequest($data, string $contentType = self::contentTypes['createFolder'][0])
    {

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createFolder'
            );
        }


        $resourcePath = '/folders/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createHtmlTemplate
     *
     * Create a new HTML template
     *
     * @param  \DocSpring\Model\CreateHtmlTemplate $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse
     */
    public function createHtmlTemplate($data, string $contentType = self::contentTypes['createHtmlTemplate'][0])
    {
        list($response) = $this->createHtmlTemplateWithHttpInfo($data, $contentType);
        return $response;
    }

    /**
     * Operation createHtmlTemplateWithHttpInfo
     *
     * Create a new HTML template
     *
     * @param  \DocSpring\Model\CreateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createHtmlTemplateWithHttpInfo($data, string $contentType = self::contentTypes['createHtmlTemplate'][0])
    {
        $request = $this->createHtmlTemplateRequest($data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createHtmlTemplateAsync
     *
     * Create a new HTML template
     *
     * @param  \DocSpring\Model\CreateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHtmlTemplateAsync($data, string $contentType = self::contentTypes['createHtmlTemplate'][0])
    {
        return $this->createHtmlTemplateAsyncWithHttpInfo($data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createHtmlTemplateAsyncWithHttpInfo
     *
     * Create a new HTML template
     *
     * @param  \DocSpring\Model\CreateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHtmlTemplateAsyncWithHttpInfo($data, string $contentType = self::contentTypes['createHtmlTemplate'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview';
        $request = $this->createHtmlTemplateRequest($data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createHtmlTemplate'
     *
     * @param  \DocSpring\Model\CreateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createHtmlTemplateRequest($data, string $contentType = self::contentTypes['createHtmlTemplate'][0])
    {

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createHtmlTemplate'
            );
        }


        $resourcePath = '/templates?endpoint_variant=create_html_template';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPdfTemplate
     *
     * Create a new PDF template with a form POST file upload
     *
     * @param  \SplFileObject $template_document template_document (required)
     * @param  string $template_name template_name (required)
     * @param  bool|null $wait Wait for template document to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string|null $template_description template_description (optional)
     * @param  string|null $template_parent_folder_id template_parent_folder_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse
     */
    public function createPdfTemplate($template_document, $template_name, $wait = true, $template_description = null, $template_parent_folder_id = null, string $contentType = self::contentTypes['createPdfTemplate'][0])
    {
        list($response) = $this->createPdfTemplateWithHttpInfo($template_document, $template_name, $wait, $template_description, $template_parent_folder_id, $contentType);
        return $response;
    }

    /**
     * Operation createPdfTemplateWithHttpInfo
     *
     * Create a new PDF template with a form POST file upload
     *
     * @param  \SplFileObject $template_document (required)
     * @param  string $template_name (required)
     * @param  bool|null $wait Wait for template document to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string|null $template_description (optional)
     * @param  string|null $template_parent_folder_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPdfTemplateWithHttpInfo($template_document, $template_name, $wait = true, $template_description = null, $template_parent_folder_id = null, string $contentType = self::contentTypes['createPdfTemplate'][0])
    {
        $request = $this->createPdfTemplateRequest($template_document, $template_name, $wait, $template_description, $template_parent_folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createPdfTemplateAsync
     *
     * Create a new PDF template with a form POST file upload
     *
     * @param  \SplFileObject $template_document (required)
     * @param  string $template_name (required)
     * @param  bool|null $wait Wait for template document to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string|null $template_description (optional)
     * @param  string|null $template_parent_folder_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPdfTemplateAsync($template_document, $template_name, $wait = true, $template_description = null, $template_parent_folder_id = null, string $contentType = self::contentTypes['createPdfTemplate'][0])
    {
        return $this->createPdfTemplateAsyncWithHttpInfo($template_document, $template_name, $wait, $template_description, $template_parent_folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPdfTemplateAsyncWithHttpInfo
     *
     * Create a new PDF template with a form POST file upload
     *
     * @param  \SplFileObject $template_document (required)
     * @param  string $template_name (required)
     * @param  bool|null $wait Wait for template document to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string|null $template_description (optional)
     * @param  string|null $template_parent_folder_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPdfTemplateAsyncWithHttpInfo($template_document, $template_name, $wait = true, $template_description = null, $template_parent_folder_id = null, string $contentType = self::contentTypes['createPdfTemplate'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview';
        $request = $this->createPdfTemplateRequest($template_document, $template_name, $wait, $template_description, $template_parent_folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPdfTemplate'
     *
     * @param  \SplFileObject $template_document (required)
     * @param  string $template_name (required)
     * @param  bool|null $wait Wait for template document to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string|null $template_description (optional)
     * @param  string|null $template_parent_folder_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPdfTemplateRequest($template_document, $template_name, $wait = true, $template_description = null, $template_parent_folder_id = null, string $contentType = self::contentTypes['createPdfTemplate'][0])
    {

        // verify the required parameter 'template_document' is set
        if ($template_document === null || (is_array($template_document) && count($template_document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_document when calling createPdfTemplate'
            );
        }

        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling createPdfTemplate'
            );
        }





        $resourcePath = '/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wait,
            'wait', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);



// Manually build multipart with bracketed keys and filename for proper Rack upload handling
$multipart = true;
$headers = $this->headerSelector->selectHeaders(
    ['application/json', ],
    $contentType,
    $multipart
);

$multipartContents = [];
// template[document]
if ($template_document instanceof \SplFileObject) {
    $path = $template_document->getRealPath();
    $filename = basename($path);
    $stream = \GuzzleHttp\Psr7\Utils::tryFopen($path, 'rb');
    $multipartContents[] = [
        'name' => 'template[document]',
        'contents' => $stream,
        'filename' => $filename,
    ];
} else {
    $multipartContents[] = [
        'name' => 'template[document]',
        'contents' => $template_document,
    ];
}
// template[name]
$multipartContents[] = [ 'name' => 'template[name]', 'contents' => $template_name ];
// optional template[description]
if ($template_description !== null) {
    $multipartContents[] = [ 'name' => 'template[description]', 'contents' => $template_description ];
}
// optional template[parent_folder_id]
if ($template_parent_folder_id !== null) {
    $multipartContents[] = [ 'name' => 'template[parent_folder_id]', 'contents' => $template_parent_folder_id ];
}

// Build multipart body
$httpBody = new \GuzzleHttp\Psr7\MultipartStream($multipartContents);


        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPdfTemplateFromUpload
     *
     * Create a new PDF template from a cached S3 file upload
     *
     * @param  \DocSpring\Model\CreatePdfTemplate $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplateFromUpload'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse
     */
    public function createPdfTemplateFromUpload($data, string $contentType = self::contentTypes['createPdfTemplateFromUpload'][0])
    {
        list($response) = $this->createPdfTemplateFromUploadWithHttpInfo($data, $contentType);
        return $response;
    }

    /**
     * Operation createPdfTemplateFromUploadWithHttpInfo
     *
     * Create a new PDF template from a cached S3 file upload
     *
     * @param  \DocSpring\Model\CreatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplateFromUpload'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPdfTemplateFromUploadWithHttpInfo($data, string $contentType = self::contentTypes['createPdfTemplateFromUpload'][0])
    {
        $request = $this->createPdfTemplateFromUploadRequest($data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createPdfTemplateFromUploadAsync
     *
     * Create a new PDF template from a cached S3 file upload
     *
     * @param  \DocSpring\Model\CreatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplateFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPdfTemplateFromUploadAsync($data, string $contentType = self::contentTypes['createPdfTemplateFromUpload'][0])
    {
        return $this->createPdfTemplateFromUploadAsyncWithHttpInfo($data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPdfTemplateFromUploadAsyncWithHttpInfo
     *
     * Create a new PDF template from a cached S3 file upload
     *
     * @param  \DocSpring\Model\CreatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplateFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPdfTemplateFromUploadAsyncWithHttpInfo($data, string $contentType = self::contentTypes['createPdfTemplateFromUpload'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview';
        $request = $this->createPdfTemplateFromUploadRequest($data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPdfTemplateFromUpload'
     *
     * @param  \DocSpring\Model\CreatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPdfTemplateFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPdfTemplateFromUploadRequest($data, string $contentType = self::contentTypes['createPdfTemplateFromUpload'][0])
    {

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createPdfTemplateFromUpload'
            );
        }


        $resourcePath = '/templates?endpoint_variant=create_template_from_cached_upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFolder
     *
     * Delete a folder
     *
     * @param  string $folder_id folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse
     */
    public function deleteFolder($folder_id, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        list($response) = $this->deleteFolderWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteFolderWithHttpInfo
     *
     * Delete a folder
     *
     * @param  string $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderWithHttpInfo($folder_id, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        $request = $this->deleteFolderRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Folder',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Folder',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFolderAsync
     *
     * Delete a folder
     *
     * @param  string $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync($folder_id, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        return $this->deleteFolderAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * Delete a folder
     *
     * @param  string $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        $returnType = '\DocSpring\Model\Folder';
        $request = $this->deleteFolderRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolder'
     *
     * @param  string $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFolderRequest($folder_id, string $contentType = self::contentTypes['deleteFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling deleteFolder'
            );
        }


        $resourcePath = '/folders/{folder_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folder_id' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTemplate
     *
     * Delete a template
     *
     * @param  string $template_id template_id (required)
     * @param  string|null $version version (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplateDeleteResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function deleteTemplate($template_id, $version = null, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        list($response) = $this->deleteTemplateWithHttpInfo($template_id, $version, $contentType);
        return $response;
    }

    /**
     * Operation deleteTemplateWithHttpInfo
     *
     * Delete a template
     *
     * @param  string $template_id (required)
     * @param  string|null $version (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplateDeleteResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTemplateWithHttpInfo($template_id, $version = null, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        $request = $this->deleteTemplateRequest($template_id, $version, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplateDeleteResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplateDeleteResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplateDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTemplateAsync
     *
     * Delete a template
     *
     * @param  string $template_id (required)
     * @param  string|null $version (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplateAsync($template_id, $version = null, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        return $this->deleteTemplateAsyncWithHttpInfo($template_id, $version, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTemplateAsyncWithHttpInfo
     *
     * Delete a template
     *
     * @param  string $template_id (required)
     * @param  string|null $version (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplateAsyncWithHttpInfo($template_id, $version = null, string $contentType = self::contentTypes['deleteTemplate'][0])
    {
        $returnType = '\DocSpring\Model\TemplateDeleteResponse';
        $request = $this->deleteTemplateRequest($template_id, $version, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTemplate'
     *
     * @param  string $template_id (required)
     * @param  string|null $version (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTemplateRequest($template_id, $version = null, string $contentType = self::contentTypes['deleteTemplate'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling deleteTemplate'
            );
        }



        $resourcePath = '/templates/{template_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation expireCombinedSubmission
     *
     * Expire a combined submission
     *
     * @param  string $combined_submission_id combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CombinedSubmission|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function expireCombinedSubmission($combined_submission_id, string $contentType = self::contentTypes['expireCombinedSubmission'][0])
    {
        list($response) = $this->expireCombinedSubmissionWithHttpInfo($combined_submission_id, $contentType);
        return $response;
    }

    /**
     * Operation expireCombinedSubmissionWithHttpInfo
     *
     * Expire a combined submission
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CombinedSubmission|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function expireCombinedSubmissionWithHttpInfo($combined_submission_id, string $contentType = self::contentTypes['expireCombinedSubmission'][0])
    {
        $request = $this->expireCombinedSubmissionRequest($combined_submission_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CombinedSubmission',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CombinedSubmission',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CombinedSubmission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation expireCombinedSubmissionAsync
     *
     * Expire a combined submission
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function expireCombinedSubmissionAsync($combined_submission_id, string $contentType = self::contentTypes['expireCombinedSubmission'][0])
    {
        return $this->expireCombinedSubmissionAsyncWithHttpInfo($combined_submission_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation expireCombinedSubmissionAsyncWithHttpInfo
     *
     * Expire a combined submission
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function expireCombinedSubmissionAsyncWithHttpInfo($combined_submission_id, string $contentType = self::contentTypes['expireCombinedSubmission'][0])
    {
        $returnType = '\DocSpring\Model\CombinedSubmission';
        $request = $this->expireCombinedSubmissionRequest($combined_submission_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'expireCombinedSubmission'
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function expireCombinedSubmissionRequest($combined_submission_id, string $contentType = self::contentTypes['expireCombinedSubmission'][0])
    {

        // verify the required parameter 'combined_submission_id' is set
        if ($combined_submission_id === null || (is_array($combined_submission_id) && count($combined_submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $combined_submission_id when calling expireCombinedSubmission'
            );
        }


        $resourcePath = '/combined_submissions/{combined_submission_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($combined_submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'combined_submission_id' . '}',
                ObjectSerializer::toPathValue($combined_submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation expireSubmission
     *
     * Expire a PDF submission
     *
     * @param  string $submission_id submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SubmissionPreview|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function expireSubmission($submission_id, string $contentType = self::contentTypes['expireSubmission'][0])
    {
        list($response) = $this->expireSubmissionWithHttpInfo($submission_id, $contentType);
        return $response;
    }

    /**
     * Operation expireSubmissionWithHttpInfo
     *
     * Expire a PDF submission
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SubmissionPreview|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function expireSubmissionWithHttpInfo($submission_id, string $contentType = self::contentTypes['expireSubmission'][0])
    {
        $request = $this->expireSubmissionRequest($submission_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SubmissionPreview',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SubmissionPreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SubmissionPreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation expireSubmissionAsync
     *
     * Expire a PDF submission
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function expireSubmissionAsync($submission_id, string $contentType = self::contentTypes['expireSubmission'][0])
    {
        return $this->expireSubmissionAsyncWithHttpInfo($submission_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation expireSubmissionAsyncWithHttpInfo
     *
     * Expire a PDF submission
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function expireSubmissionAsyncWithHttpInfo($submission_id, string $contentType = self::contentTypes['expireSubmission'][0])
    {
        $returnType = '\DocSpring\Model\SubmissionPreview';
        $request = $this->expireSubmissionRequest($submission_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'expireSubmission'
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['expireSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function expireSubmissionRequest($submission_id, string $contentType = self::contentTypes['expireSubmission'][0])
    {

        // verify the required parameter 'submission_id' is set
        if ($submission_id === null || (is_array($submission_id) && count($submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_id when calling expireSubmission'
            );
        }


        $resourcePath = '/submissions/{submission_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submission_id' . '}',
                ObjectSerializer::toPathValue($submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generatePdf
     *
     * Generate a PDF
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\CreatePdfSubmissionData $submission submission (required)
     * @param  bool|null $wait Wait for submission to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePdf'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CreateSubmissionResponse|\DocSpring\Model\Submission422Response|\DocSpring\Model\ErrorResponse
     */
    public function generatePdf($template_id, $submission, $wait = true, string $contentType = self::contentTypes['generatePdf'][0])
    {
        list($response) = $this->generatePdfWithHttpInfo($template_id, $submission, $wait, $contentType);
        return $response;
    }

    /**
     * Operation generatePdfWithHttpInfo
     *
     * Generate a PDF
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CreatePdfSubmissionData $submission (required)
     * @param  bool|null $wait Wait for submission to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePdf'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CreateSubmissionResponse|\DocSpring\Model\Submission422Response|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function generatePdfWithHttpInfo($template_id, $submission, $wait = true, string $contentType = self::contentTypes['generatePdf'][0])
    {
        $request = $this->generatePdfRequest($template_id, $submission, $wait, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CreateSubmissionResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Submission422Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CreateSubmissionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CreateSubmissionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Submission422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation generatePdfAsync
     *
     * Generate a PDF
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CreatePdfSubmissionData $submission (required)
     * @param  bool|null $wait Wait for submission to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generatePdfAsync($template_id, $submission, $wait = true, string $contentType = self::contentTypes['generatePdf'][0])
    {
        return $this->generatePdfAsyncWithHttpInfo($template_id, $submission, $wait, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generatePdfAsyncWithHttpInfo
     *
     * Generate a PDF
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CreatePdfSubmissionData $submission (required)
     * @param  bool|null $wait Wait for submission to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generatePdfAsyncWithHttpInfo($template_id, $submission, $wait = true, string $contentType = self::contentTypes['generatePdf'][0])
    {
        $returnType = '\DocSpring\Model\CreateSubmissionResponse';
        $request = $this->generatePdfRequest($template_id, $submission, $wait, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generatePdf'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\CreatePdfSubmissionData $submission (required)
     * @param  bool|null $wait Wait for submission to be processed before returning. Set to false to return immediately. Default: true (on sync.* subdomain) (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generatePdfRequest($template_id, $submission, $wait = true, string $contentType = self::contentTypes['generatePdf'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling generatePdf'
            );
        }

        // verify the required parameter 'submission' is set
        if ($submission === null || (is_array($submission) && count($submission) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission when calling generatePdf'
            );
        }



        $resourcePath = '/templates/{template_id}/submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wait,
            'wait', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($submission)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($submission));
            } else {
                $httpBody = $submission;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generatePreview
     *
     * Generate a preview PDF for partially completed data requests
     *
     * @param  string $submission_id submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePreview'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SuccessErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\SuccessErrorResponse
     */
    public function generatePreview($submission_id, string $contentType = self::contentTypes['generatePreview'][0])
    {
        list($response) = $this->generatePreviewWithHttpInfo($submission_id, $contentType);
        return $response;
    }

    /**
     * Operation generatePreviewWithHttpInfo
     *
     * Generate a preview PDF for partially completed data requests
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePreview'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SuccessErrorResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\SuccessErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function generatePreviewWithHttpInfo($submission_id, string $contentType = self::contentTypes['generatePreview'][0])
    {
        $request = $this->generatePreviewRequest($submission_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessErrorResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SuccessErrorResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation generatePreviewAsync
     *
     * Generate a preview PDF for partially completed data requests
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generatePreviewAsync($submission_id, string $contentType = self::contentTypes['generatePreview'][0])
    {
        return $this->generatePreviewAsyncWithHttpInfo($submission_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generatePreviewAsyncWithHttpInfo
     *
     * Generate a preview PDF for partially completed data requests
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generatePreviewAsyncWithHttpInfo($submission_id, string $contentType = self::contentTypes['generatePreview'][0])
    {
        $returnType = '\DocSpring\Model\SuccessErrorResponse';
        $request = $this->generatePreviewRequest($submission_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generatePreview'
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generatePreview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generatePreviewRequest($submission_id, string $contentType = self::contentTypes['generatePreview'][0])
    {

        // verify the required parameter 'submission_id' is set
        if ($submission_id === null || (is_array($submission_id) && count($submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_id when calling generatePreview'
            );
        }


        $resourcePath = '/submissions/{submission_id}/generate_preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submission_id' . '}',
                ObjectSerializer::toPathValue($submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCombinedSubmission
     *
     * Check the status of a combined submission (merged PDFs)
     *
     * @param  string $combined_submission_id combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CombinedSubmission|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getCombinedSubmission($combined_submission_id, string $contentType = self::contentTypes['getCombinedSubmission'][0])
    {
        list($response) = $this->getCombinedSubmissionWithHttpInfo($combined_submission_id, $contentType);
        return $response;
    }

    /**
     * Operation getCombinedSubmissionWithHttpInfo
     *
     * Check the status of a combined submission (merged PDFs)
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CombinedSubmission|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCombinedSubmissionWithHttpInfo($combined_submission_id, string $contentType = self::contentTypes['getCombinedSubmission'][0])
    {
        $request = $this->getCombinedSubmissionRequest($combined_submission_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CombinedSubmission',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CombinedSubmission',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CombinedSubmission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCombinedSubmissionAsync
     *
     * Check the status of a combined submission (merged PDFs)
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCombinedSubmissionAsync($combined_submission_id, string $contentType = self::contentTypes['getCombinedSubmission'][0])
    {
        return $this->getCombinedSubmissionAsyncWithHttpInfo($combined_submission_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCombinedSubmissionAsyncWithHttpInfo
     *
     * Check the status of a combined submission (merged PDFs)
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCombinedSubmissionAsyncWithHttpInfo($combined_submission_id, string $contentType = self::contentTypes['getCombinedSubmission'][0])
    {
        $returnType = '\DocSpring\Model\CombinedSubmission';
        $request = $this->getCombinedSubmissionRequest($combined_submission_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCombinedSubmission'
     *
     * @param  string $combined_submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCombinedSubmissionRequest($combined_submission_id, string $contentType = self::contentTypes['getCombinedSubmission'][0])
    {

        // verify the required parameter 'combined_submission_id' is set
        if ($combined_submission_id === null || (is_array($combined_submission_id) && count($combined_submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $combined_submission_id when calling getCombinedSubmission'
            );
        }


        $resourcePath = '/combined_submissions/{combined_submission_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($combined_submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'combined_submission_id' . '}',
                ObjectSerializer::toPathValue($combined_submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDataRequest
     *
     * Look up a submission data request
     *
     * @param  string $data_request_id data_request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDataRequest'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SubmissionDataRequestShow|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getDataRequest($data_request_id, string $contentType = self::contentTypes['getDataRequest'][0])
    {
        list($response) = $this->getDataRequestWithHttpInfo($data_request_id, $contentType);
        return $response;
    }

    /**
     * Operation getDataRequestWithHttpInfo
     *
     * Look up a submission data request
     *
     * @param  string $data_request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDataRequest'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SubmissionDataRequestShow|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDataRequestWithHttpInfo($data_request_id, string $contentType = self::contentTypes['getDataRequest'][0])
    {
        $request = $this->getDataRequestRequest($data_request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SubmissionDataRequestShow',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SubmissionDataRequestShow',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SubmissionDataRequestShow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDataRequestAsync
     *
     * Look up a submission data request
     *
     * @param  string $data_request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDataRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDataRequestAsync($data_request_id, string $contentType = self::contentTypes['getDataRequest'][0])
    {
        return $this->getDataRequestAsyncWithHttpInfo($data_request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDataRequestAsyncWithHttpInfo
     *
     * Look up a submission data request
     *
     * @param  string $data_request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDataRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDataRequestAsyncWithHttpInfo($data_request_id, string $contentType = self::contentTypes['getDataRequest'][0])
    {
        $returnType = '\DocSpring\Model\SubmissionDataRequestShow';
        $request = $this->getDataRequestRequest($data_request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDataRequest'
     *
     * @param  string $data_request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDataRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDataRequestRequest($data_request_id, string $contentType = self::contentTypes['getDataRequest'][0])
    {

        // verify the required parameter 'data_request_id' is set
        if ($data_request_id === null || (is_array($data_request_id) && count($data_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data_request_id when calling getDataRequest'
            );
        }


        $resourcePath = '/data_requests/{data_request_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($data_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'data_request_id' . '}',
                ObjectSerializer::toPathValue($data_request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFullTemplate
     *
     * Fetch the full attributes for a PDF template
     *
     * @param  string $template_id template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\Template|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getFullTemplate($template_id, string $contentType = self::contentTypes['getFullTemplate'][0])
    {
        list($response) = $this->getFullTemplateWithHttpInfo($template_id, $contentType);
        return $response;
    }

    /**
     * Operation getFullTemplateWithHttpInfo
     *
     * Fetch the full attributes for a PDF template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\Template|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFullTemplateWithHttpInfo($template_id, string $contentType = self::contentTypes['getFullTemplate'][0])
    {
        $request = $this->getFullTemplateRequest($template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Template',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Template',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Template',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFullTemplateAsync
     *
     * Fetch the full attributes for a PDF template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullTemplateAsync($template_id, string $contentType = self::contentTypes['getFullTemplate'][0])
    {
        return $this->getFullTemplateAsyncWithHttpInfo($template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFullTemplateAsyncWithHttpInfo
     *
     * Fetch the full attributes for a PDF template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullTemplateAsyncWithHttpInfo($template_id, string $contentType = self::contentTypes['getFullTemplate'][0])
    {
        $returnType = '\DocSpring\Model\Template';
        $request = $this->getFullTemplateRequest($template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFullTemplate'
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFullTemplateRequest($template_id, string $contentType = self::contentTypes['getFullTemplate'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling getFullTemplate'
            );
        }


        $resourcePath = '/templates/{template_id}?full=true';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPresignUrl
     *
     * Get a presigned S3 URL for direct file upload
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignUrl'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\UploadPresignResponse|\DocSpring\Model\ErrorResponse
     */
    public function getPresignUrl(string $contentType = self::contentTypes['getPresignUrl'][0])
    {
        list($response) = $this->getPresignUrlWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getPresignUrlWithHttpInfo
     *
     * Get a presigned S3 URL for direct file upload
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignUrl'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\UploadPresignResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPresignUrlWithHttpInfo(string $contentType = self::contentTypes['getPresignUrl'][0])
    {
        $request = $this->getPresignUrlRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\UploadPresignResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\UploadPresignResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\UploadPresignResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPresignUrlAsync
     *
     * Get a presigned S3 URL for direct file upload
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPresignUrlAsync(string $contentType = self::contentTypes['getPresignUrl'][0])
    {
        return $this->getPresignUrlAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPresignUrlAsyncWithHttpInfo
     *
     * Get a presigned S3 URL for direct file upload
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPresignUrlAsyncWithHttpInfo(string $contentType = self::contentTypes['getPresignUrl'][0])
    {
        $returnType = '\DocSpring\Model\UploadPresignResponse';
        $request = $this->getPresignUrlRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPresignUrl'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPresignUrlRequest(string $contentType = self::contentTypes['getPresignUrl'][0])
    {


        $resourcePath = '/uploads/presign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubmission
     *
     * Check the status of a PDF
     *
     * @param  string $submission_id submission_id (required)
     * @param  bool|null $include_data include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\Submission|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getSubmission($submission_id, $include_data = null, string $contentType = self::contentTypes['getSubmission'][0])
    {
        list($response) = $this->getSubmissionWithHttpInfo($submission_id, $include_data, $contentType);
        return $response;
    }

    /**
     * Operation getSubmissionWithHttpInfo
     *
     * Check the status of a PDF
     *
     * @param  string $submission_id (required)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\Submission|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubmissionWithHttpInfo($submission_id, $include_data = null, string $contentType = self::contentTypes['getSubmission'][0])
    {
        $request = $this->getSubmissionRequest($submission_id, $include_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Submission',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Submission',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Submission',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSubmissionAsync
     *
     * Check the status of a PDF
     *
     * @param  string $submission_id (required)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionAsync($submission_id, $include_data = null, string $contentType = self::contentTypes['getSubmission'][0])
    {
        return $this->getSubmissionAsyncWithHttpInfo($submission_id, $include_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubmissionAsyncWithHttpInfo
     *
     * Check the status of a PDF
     *
     * @param  string $submission_id (required)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionAsyncWithHttpInfo($submission_id, $include_data = null, string $contentType = self::contentTypes['getSubmission'][0])
    {
        $returnType = '\DocSpring\Model\Submission';
        $request = $this->getSubmissionRequest($submission_id, $include_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubmission'
     *
     * @param  string $submission_id (required)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubmissionRequest($submission_id, $include_data = null, string $contentType = self::contentTypes['getSubmission'][0])
    {

        // verify the required parameter 'submission_id' is set
        if ($submission_id === null || (is_array($submission_id) && count($submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_id when calling getSubmission'
            );
        }



        $resourcePath = '/submissions/{submission_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_data,
            'include_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submission_id' . '}',
                ObjectSerializer::toPathValue($submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubmissionBatch
     *
     * Check the status of a submission batch job
     *
     * @param  string $submission_batch_id submission_batch_id (required)
     * @param  bool|null $include_submissions include_submissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissionBatch'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SubmissionBatchWithSubmissions|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getSubmissionBatch($submission_batch_id, $include_submissions = null, string $contentType = self::contentTypes['getSubmissionBatch'][0])
    {
        list($response) = $this->getSubmissionBatchWithHttpInfo($submission_batch_id, $include_submissions, $contentType);
        return $response;
    }

    /**
     * Operation getSubmissionBatchWithHttpInfo
     *
     * Check the status of a submission batch job
     *
     * @param  string $submission_batch_id (required)
     * @param  bool|null $include_submissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissionBatch'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SubmissionBatchWithSubmissions|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubmissionBatchWithHttpInfo($submission_batch_id, $include_submissions = null, string $contentType = self::contentTypes['getSubmissionBatch'][0])
    {
        $request = $this->getSubmissionBatchRequest($submission_batch_id, $include_submissions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SubmissionBatchWithSubmissions',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SubmissionBatchWithSubmissions',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SubmissionBatchWithSubmissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSubmissionBatchAsync
     *
     * Check the status of a submission batch job
     *
     * @param  string $submission_batch_id (required)
     * @param  bool|null $include_submissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissionBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionBatchAsync($submission_batch_id, $include_submissions = null, string $contentType = self::contentTypes['getSubmissionBatch'][0])
    {
        return $this->getSubmissionBatchAsyncWithHttpInfo($submission_batch_id, $include_submissions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubmissionBatchAsyncWithHttpInfo
     *
     * Check the status of a submission batch job
     *
     * @param  string $submission_batch_id (required)
     * @param  bool|null $include_submissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissionBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionBatchAsyncWithHttpInfo($submission_batch_id, $include_submissions = null, string $contentType = self::contentTypes['getSubmissionBatch'][0])
    {
        $returnType = '\DocSpring\Model\SubmissionBatchWithSubmissions';
        $request = $this->getSubmissionBatchRequest($submission_batch_id, $include_submissions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubmissionBatch'
     *
     * @param  string $submission_batch_id (required)
     * @param  bool|null $include_submissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissionBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubmissionBatchRequest($submission_batch_id, $include_submissions = null, string $contentType = self::contentTypes['getSubmissionBatch'][0])
    {

        // verify the required parameter 'submission_batch_id' is set
        if ($submission_batch_id === null || (is_array($submission_batch_id) && count($submission_batch_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_batch_id when calling getSubmissionBatch'
            );
        }



        $resourcePath = '/submissions/batches/{submission_batch_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_submissions,
            'include_submissions', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($submission_batch_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submission_batch_id' . '}',
                ObjectSerializer::toPathValue($submission_batch_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplate
     *
     * Check the status of an uploaded template
     *
     * @param  string $template_id template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getTemplate($template_id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        list($response) = $this->getTemplateWithHttpInfo($template_id, $contentType);
        return $response;
    }

    /**
     * Operation getTemplateWithHttpInfo
     *
     * Check the status of an uploaded template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplateWithHttpInfo($template_id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        $request = $this->getTemplateRequest($template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTemplateAsync
     *
     * Check the status of an uploaded template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsync($template_id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        return $this->getTemplateAsyncWithHttpInfo($template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplateAsyncWithHttpInfo
     *
     * Check the status of an uploaded template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsyncWithHttpInfo($template_id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview';
        $request = $this->getTemplateRequest($template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplate'
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTemplateRequest($template_id, string $contentType = self::contentTypes['getTemplate'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling getTemplate'
            );
        }


        $resourcePath = '/templates/{template_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplateSchema
     *
     * Fetch the JSON schema for a template
     *
     * @param  string $template_id template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplateSchema'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\JsonSchema|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function getTemplateSchema($template_id, string $contentType = self::contentTypes['getTemplateSchema'][0])
    {
        list($response) = $this->getTemplateSchemaWithHttpInfo($template_id, $contentType);
        return $response;
    }

    /**
     * Operation getTemplateSchemaWithHttpInfo
     *
     * Fetch the JSON schema for a template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplateSchema'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\JsonSchema|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplateSchemaWithHttpInfo($template_id, string $contentType = self::contentTypes['getTemplateSchema'][0])
    {
        $request = $this->getTemplateSchemaRequest($template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\JsonSchema',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\JsonSchema',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\JsonSchema',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTemplateSchemaAsync
     *
     * Fetch the JSON schema for a template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplateSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateSchemaAsync($template_id, string $contentType = self::contentTypes['getTemplateSchema'][0])
    {
        return $this->getTemplateSchemaAsyncWithHttpInfo($template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplateSchemaAsyncWithHttpInfo
     *
     * Fetch the JSON schema for a template
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplateSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateSchemaAsyncWithHttpInfo($template_id, string $contentType = self::contentTypes['getTemplateSchema'][0])
    {
        $returnType = '\DocSpring\Model\JsonSchema';
        $request = $this->getTemplateSchemaRequest($template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplateSchema'
     *
     * @param  string $template_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplateSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTemplateSchemaRequest($template_id, string $contentType = self::contentTypes['getTemplateSchema'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling getTemplateSchema'
            );
        }


        $resourcePath = '/templates/{template_id}/schema';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCombinedSubmissions
     *
     * Get a list of all combined submissions
     *
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCombinedSubmissions'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CombinedSubmission[]|\DocSpring\Model\ErrorResponse
     */
    public function listCombinedSubmissions($page = null, $per_page = null, string $contentType = self::contentTypes['listCombinedSubmissions'][0])
    {
        list($response) = $this->listCombinedSubmissionsWithHttpInfo($page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation listCombinedSubmissionsWithHttpInfo
     *
     * Get a list of all combined submissions
     *
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCombinedSubmissions'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CombinedSubmission[]|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCombinedSubmissionsWithHttpInfo($page = null, $per_page = null, string $contentType = self::contentTypes['listCombinedSubmissions'][0])
    {
        $request = $this->listCombinedSubmissionsRequest($page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CombinedSubmission[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CombinedSubmission[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CombinedSubmission[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCombinedSubmissionsAsync
     *
     * Get a list of all combined submissions
     *
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCombinedSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCombinedSubmissionsAsync($page = null, $per_page = null, string $contentType = self::contentTypes['listCombinedSubmissions'][0])
    {
        return $this->listCombinedSubmissionsAsyncWithHttpInfo($page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCombinedSubmissionsAsyncWithHttpInfo
     *
     * Get a list of all combined submissions
     *
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCombinedSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCombinedSubmissionsAsyncWithHttpInfo($page = null, $per_page = null, string $contentType = self::contentTypes['listCombinedSubmissions'][0])
    {
        $returnType = '\DocSpring\Model\CombinedSubmission[]';
        $request = $this->listCombinedSubmissionsRequest($page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCombinedSubmissions'
     *
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCombinedSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCombinedSubmissionsRequest($page = null, $per_page = null, string $contentType = self::contentTypes['listCombinedSubmissions'][0])
    {

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling Client.listCombinedSubmissions, must be bigger than or equal to 1.');
        }
        
        if ($per_page !== null && $per_page > 50) {
            throw new \InvalidArgumentException('invalid value for "$per_page" when calling Client.listCombinedSubmissions, must be smaller than or equal to 50.');
        }
        if ($per_page !== null && $per_page < 1) {
            throw new \InvalidArgumentException('invalid value for "$per_page" when calling Client.listCombinedSubmissions, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/combined_submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFolders
     *
     * Get a list of all folders
     *
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFolders'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\Folder[]|\DocSpring\Model\ErrorResponse
     */
    public function listFolders($parent_folder_id = null, string $contentType = self::contentTypes['listFolders'][0])
    {
        list($response) = $this->listFoldersWithHttpInfo($parent_folder_id, $contentType);
        return $response;
    }

    /**
     * Operation listFoldersWithHttpInfo
     *
     * Get a list of all folders
     *
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFolders'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\Folder[]|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFoldersWithHttpInfo($parent_folder_id = null, string $contentType = self::contentTypes['listFolders'][0])
    {
        $request = $this->listFoldersRequest($parent_folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Folder[]',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Folder[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Folder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listFoldersAsync
     *
     * Get a list of all folders
     *
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoldersAsync($parent_folder_id = null, string $contentType = self::contentTypes['listFolders'][0])
    {
        return $this->listFoldersAsyncWithHttpInfo($parent_folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFoldersAsyncWithHttpInfo
     *
     * Get a list of all folders
     *
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoldersAsyncWithHttpInfo($parent_folder_id = null, string $contentType = self::contentTypes['listFolders'][0])
    {
        $returnType = '\DocSpring\Model\Folder[]';
        $request = $this->listFoldersRequest($parent_folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFolders'
     *
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listFoldersRequest($parent_folder_id = null, string $contentType = self::contentTypes['listFolders'][0])
    {



        $resourcePath = '/folders/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_folder_id,
            'parent_folder_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSubmissions
     *
     * List all submissions
     *
     * @param  string|null $cursor cursor (optional)
     * @param  int|null $limit limit (optional)
     * @param  string|null $created_after created_after (optional)
     * @param  string|null $created_before created_before (optional)
     * @param  string|null $type type (optional)
     * @param  bool|null $include_data include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSubmissions'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\ListSubmissionsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function listSubmissions($cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listSubmissions'][0])
    {
        list($response) = $this->listSubmissionsWithHttpInfo($cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType);
        return $response;
    }

    /**
     * Operation listSubmissionsWithHttpInfo
     *
     * List all submissions
     *
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSubmissions'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\ListSubmissionsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSubmissionsWithHttpInfo($cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listSubmissions'][0])
    {
        $request = $this->listSubmissionsRequest($cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ListSubmissionsResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\ListSubmissionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ListSubmissionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listSubmissionsAsync
     *
     * List all submissions
     *
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSubmissionsAsync($cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listSubmissions'][0])
    {
        return $this->listSubmissionsAsyncWithHttpInfo($cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSubmissionsAsyncWithHttpInfo
     *
     * List all submissions
     *
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSubmissionsAsyncWithHttpInfo($cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listSubmissions'][0])
    {
        $returnType = '\DocSpring\Model\ListSubmissionsResponse';
        $request = $this->listSubmissionsRequest($cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSubmissions'
     *
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listSubmissionsRequest($cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listSubmissions'][0])
    {








        $resourcePath = '/submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_after,
            'created_after', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_before,
            'created_before', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_data,
            'include_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTemplateSubmissions
     *
     * List all submissions for a given template
     *
     * @param  string $template_id template_id (required)
     * @param  string|null $cursor cursor (optional)
     * @param  int|null $limit limit (optional)
     * @param  string|null $created_after created_after (optional)
     * @param  string|null $created_before created_before (optional)
     * @param  string|null $type type (optional)
     * @param  bool|null $include_data include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplateSubmissions'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\ListSubmissionsResponse|\DocSpring\Model\ErrorResponse
     */
    public function listTemplateSubmissions($template_id, $cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listTemplateSubmissions'][0])
    {
        list($response) = $this->listTemplateSubmissionsWithHttpInfo($template_id, $cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType);
        return $response;
    }

    /**
     * Operation listTemplateSubmissionsWithHttpInfo
     *
     * List all submissions for a given template
     *
     * @param  string $template_id (required)
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplateSubmissions'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\ListSubmissionsResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTemplateSubmissionsWithHttpInfo($template_id, $cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listTemplateSubmissions'][0])
    {
        $request = $this->listTemplateSubmissionsRequest($template_id, $cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ListSubmissionsResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\ListSubmissionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ListSubmissionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTemplateSubmissionsAsync
     *
     * List all submissions for a given template
     *
     * @param  string $template_id (required)
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplateSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTemplateSubmissionsAsync($template_id, $cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listTemplateSubmissions'][0])
    {
        return $this->listTemplateSubmissionsAsyncWithHttpInfo($template_id, $cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTemplateSubmissionsAsyncWithHttpInfo
     *
     * List all submissions for a given template
     *
     * @param  string $template_id (required)
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplateSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTemplateSubmissionsAsyncWithHttpInfo($template_id, $cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listTemplateSubmissions'][0])
    {
        $returnType = '\DocSpring\Model\ListSubmissionsResponse';
        $request = $this->listTemplateSubmissionsRequest($template_id, $cursor, $limit, $created_after, $created_before, $type, $include_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTemplateSubmissions'
     *
     * @param  string $template_id (required)
     * @param  string|null $cursor (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $created_after (optional)
     * @param  string|null $created_before (optional)
     * @param  string|null $type (optional)
     * @param  bool|null $include_data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplateSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTemplateSubmissionsRequest($template_id, $cursor = null, $limit = null, $created_after = null, $created_before = null, $type = null, $include_data = null, string $contentType = self::contentTypes['listTemplateSubmissions'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling listTemplateSubmissions'
            );
        }








        $resourcePath = '/templates/{template_id}/submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_after,
            'created_after', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_before,
            'created_before', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_data,
            'include_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTemplates
     *
     * Get a list of all templates
     *
     * @param  string|null $query Search By Name (optional)
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplates'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview[]|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function listTemplates($query = null, $parent_folder_id = null, $page = null, $per_page = null, string $contentType = self::contentTypes['listTemplates'][0])
    {
        list($response) = $this->listTemplatesWithHttpInfo($query, $parent_folder_id, $page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation listTemplatesWithHttpInfo
     *
     * Get a list of all templates
     *
     * @param  string|null $query Search By Name (optional)
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplates'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview[]|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTemplatesWithHttpInfo($query = null, $parent_folder_id = null, $page = null, $per_page = null, string $contentType = self::contentTypes['listTemplates'][0])
    {
        $request = $this->listTemplatesRequest($query, $parent_folder_id, $page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview[]',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTemplatesAsync
     *
     * Get a list of all templates
     *
     * @param  string|null $query Search By Name (optional)
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTemplatesAsync($query = null, $parent_folder_id = null, $page = null, $per_page = null, string $contentType = self::contentTypes['listTemplates'][0])
    {
        return $this->listTemplatesAsyncWithHttpInfo($query, $parent_folder_id, $page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTemplatesAsyncWithHttpInfo
     *
     * Get a list of all templates
     *
     * @param  string|null $query Search By Name (optional)
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTemplatesAsyncWithHttpInfo($query = null, $parent_folder_id = null, $page = null, $per_page = null, string $contentType = self::contentTypes['listTemplates'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview[]';
        $request = $this->listTemplatesRequest($query, $parent_folder_id, $page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTemplates'
     *
     * @param  string|null $query Search By Name (optional)
     * @param  string|null $parent_folder_id Filter By Folder Id (optional)
     * @param  int|null $page Default: 1 (optional)
     * @param  int|null $per_page Default: 50 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTemplatesRequest($query = null, $parent_folder_id = null, $page = null, $per_page = null, string $contentType = self::contentTypes['listTemplates'][0])
    {



        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling Client.listTemplates, must be bigger than or equal to 1.');
        }
        
        if ($per_page !== null && $per_page > 50) {
            throw new \InvalidArgumentException('invalid value for "$per_page" when calling Client.listTemplates, must be smaller than or equal to 50.');
        }
        if ($per_page !== null && $per_page < 1) {
            throw new \InvalidArgumentException('invalid value for "$per_page" when calling Client.listTemplates, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_folder_id,
            'parent_folder_id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveFolderToFolder
     *
     * Move a folder
     *
     * @param  string $folder_id folder_id (required)
     * @param  \DocSpring\Model\MoveFolderData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveFolderToFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse
     */
    public function moveFolderToFolder($folder_id, $data, string $contentType = self::contentTypes['moveFolderToFolder'][0])
    {
        list($response) = $this->moveFolderToFolderWithHttpInfo($folder_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation moveFolderToFolderWithHttpInfo
     *
     * Move a folder
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\MoveFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveFolderToFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveFolderToFolderWithHttpInfo($folder_id, $data, string $contentType = self::contentTypes['moveFolderToFolder'][0])
    {
        $request = $this->moveFolderToFolderRequest($folder_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Folder',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Folder',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation moveFolderToFolderAsync
     *
     * Move a folder
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\MoveFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveFolderToFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveFolderToFolderAsync($folder_id, $data, string $contentType = self::contentTypes['moveFolderToFolder'][0])
    {
        return $this->moveFolderToFolderAsyncWithHttpInfo($folder_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveFolderToFolderAsyncWithHttpInfo
     *
     * Move a folder
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\MoveFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveFolderToFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveFolderToFolderAsyncWithHttpInfo($folder_id, $data, string $contentType = self::contentTypes['moveFolderToFolder'][0])
    {
        $returnType = '\DocSpring\Model\Folder';
        $request = $this->moveFolderToFolderRequest($folder_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveFolderToFolder'
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\MoveFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveFolderToFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function moveFolderToFolderRequest($folder_id, $data, string $contentType = self::contentTypes['moveFolderToFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling moveFolderToFolder'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling moveFolderToFolder'
            );
        }


        $resourcePath = '/folders/{folder_id}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folder_id' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveTemplateToFolder
     *
     * Move Template to folder
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\MoveTemplateData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveTemplateToFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse
     */
    public function moveTemplateToFolder($template_id, $data, string $contentType = self::contentTypes['moveTemplateToFolder'][0])
    {
        list($response) = $this->moveTemplateToFolderWithHttpInfo($template_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation moveTemplateToFolderWithHttpInfo
     *
     * Move Template to folder
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\MoveTemplateData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveTemplateToFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePreview|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveTemplateToFolderWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['moveTemplateToFolder'][0])
    {
        $request = $this->moveTemplateToFolderRequest($template_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePreview',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePreview',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePreview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation moveTemplateToFolderAsync
     *
     * Move Template to folder
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\MoveTemplateData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveTemplateToFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveTemplateToFolderAsync($template_id, $data, string $contentType = self::contentTypes['moveTemplateToFolder'][0])
    {
        return $this->moveTemplateToFolderAsyncWithHttpInfo($template_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveTemplateToFolderAsyncWithHttpInfo
     *
     * Move Template to folder
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\MoveTemplateData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveTemplateToFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveTemplateToFolderAsyncWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['moveTemplateToFolder'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePreview';
        $request = $this->moveTemplateToFolderRequest($template_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveTemplateToFolder'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\MoveTemplateData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveTemplateToFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function moveTemplateToFolderRequest($template_id, $data, string $contentType = self::contentTypes['moveTemplateToFolder'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling moveTemplateToFolder'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling moveTemplateToFolder'
            );
        }


        $resourcePath = '/templates/{template_id}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation publishTemplateVersion
     *
     * Publish a template version
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\PublishVersionData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishTemplateVersion'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\TemplatePublishVersionResponse|\DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function publishTemplateVersion($template_id, $data, string $contentType = self::contentTypes['publishTemplateVersion'][0])
    {
        list($response) = $this->publishTemplateVersionWithHttpInfo($template_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation publishTemplateVersionWithHttpInfo
     *
     * Publish a template version
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\PublishVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishTemplateVersion'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\TemplatePublishVersionResponse|\DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function publishTemplateVersionWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['publishTemplateVersion'][0])
    {
        $request = $this->publishTemplateVersionRequest($template_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\TemplatePublishVersionResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\TemplatePublishVersionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\TemplatePublishVersionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation publishTemplateVersionAsync
     *
     * Publish a template version
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\PublishVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishTemplateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishTemplateVersionAsync($template_id, $data, string $contentType = self::contentTypes['publishTemplateVersion'][0])
    {
        return $this->publishTemplateVersionAsyncWithHttpInfo($template_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation publishTemplateVersionAsyncWithHttpInfo
     *
     * Publish a template version
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\PublishVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishTemplateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishTemplateVersionAsyncWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['publishTemplateVersion'][0])
    {
        $returnType = '\DocSpring\Model\TemplatePublishVersionResponse';
        $request = $this->publishTemplateVersionRequest($template_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'publishTemplateVersion'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\PublishVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishTemplateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function publishTemplateVersionRequest($template_id, $data, string $contentType = self::contentTypes['publishTemplateVersion'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling publishTemplateVersion'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling publishTemplateVersion'
            );
        }


        $resourcePath = '/templates/{template_id}/publish_version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameFolder
     *
     * Rename a folder
     *
     * @param  string $folder_id folder_id (required)
     * @param  \DocSpring\Model\RenameFolderData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse
     */
    public function renameFolder($folder_id, $data, string $contentType = self::contentTypes['renameFolder'][0])
    {
        list($response) = $this->renameFolderWithHttpInfo($folder_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation renameFolderWithHttpInfo
     *
     * Rename a folder
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\RenameFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\Folder|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameFolderWithHttpInfo($folder_id, $data, string $contentType = self::contentTypes['renameFolder'][0])
    {
        $request = $this->renameFolderRequest($folder_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\Folder',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\Folder',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\Folder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation renameFolderAsync
     *
     * Rename a folder
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\RenameFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameFolderAsync($folder_id, $data, string $contentType = self::contentTypes['renameFolder'][0])
    {
        return $this->renameFolderAsyncWithHttpInfo($folder_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameFolderAsyncWithHttpInfo
     *
     * Rename a folder
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\RenameFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameFolderAsyncWithHttpInfo($folder_id, $data, string $contentType = self::contentTypes['renameFolder'][0])
    {
        $returnType = '\DocSpring\Model\Folder';
        $request = $this->renameFolderRequest($folder_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameFolder'
     *
     * @param  string $folder_id (required)
     * @param  \DocSpring\Model\RenameFolderData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renameFolderRequest($folder_id, $data, string $contentType = self::contentTypes['renameFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling renameFolder'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling renameFolder'
            );
        }


        $resourcePath = '/folders/{folder_id}/rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folder_id' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreTemplateVersion
     *
     * Restore a template version
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\RestoreVersionData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTemplateVersion'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SuccessErrorResponse|\DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse
     */
    public function restoreTemplateVersion($template_id, $data, string $contentType = self::contentTypes['restoreTemplateVersion'][0])
    {
        list($response) = $this->restoreTemplateVersionWithHttpInfo($template_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation restoreTemplateVersionWithHttpInfo
     *
     * Restore a template version
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\RestoreVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTemplateVersion'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SuccessErrorResponse|\DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreTemplateVersionWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['restoreTemplateVersion'][0])
    {
        $request = $this->restoreTemplateVersionRequest($template_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessErrorResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SuccessErrorResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation restoreTemplateVersionAsync
     *
     * Restore a template version
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\RestoreVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTemplateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreTemplateVersionAsync($template_id, $data, string $contentType = self::contentTypes['restoreTemplateVersion'][0])
    {
        return $this->restoreTemplateVersionAsyncWithHttpInfo($template_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreTemplateVersionAsyncWithHttpInfo
     *
     * Restore a template version
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\RestoreVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTemplateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreTemplateVersionAsyncWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['restoreTemplateVersion'][0])
    {
        $returnType = '\DocSpring\Model\SuccessErrorResponse';
        $request = $this->restoreTemplateVersionRequest($template_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreTemplateVersion'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\RestoreVersionData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreTemplateVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreTemplateVersionRequest($template_id, $data, string $contentType = self::contentTypes['restoreTemplateVersion'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling restoreTemplateVersion'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling restoreTemplateVersion'
            );
        }


        $resourcePath = '/templates/{template_id}/restore_version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testAuthentication
     *
     * Test authentication
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testAuthentication'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SuccessErrorResponse|\DocSpring\Model\SuccessErrorResponse
     */
    public function testAuthentication(string $contentType = self::contentTypes['testAuthentication'][0])
    {
        list($response) = $this->testAuthenticationWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation testAuthenticationWithHttpInfo
     *
     * Test authentication
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testAuthentication'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SuccessErrorResponse|\DocSpring\Model\SuccessErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function testAuthenticationWithHttpInfo(string $contentType = self::contentTypes['testAuthentication'][0])
    {
        $request = $this->testAuthenticationRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SuccessErrorResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation testAuthenticationAsync
     *
     * Test authentication
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testAuthenticationAsync(string $contentType = self::contentTypes['testAuthentication'][0])
    {
        return $this->testAuthenticationAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testAuthenticationAsyncWithHttpInfo
     *
     * Test authentication
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testAuthenticationAsyncWithHttpInfo(string $contentType = self::contentTypes['testAuthentication'][0])
    {
        $returnType = '\DocSpring\Model\SuccessErrorResponse';
        $request = $this->testAuthenticationRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testAuthentication'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testAuthentication'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testAuthenticationRequest(string $contentType = self::contentTypes['testAuthentication'][0])
    {


        $resourcePath = '/authentication';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDataRequest
     *
     * Update a submission data request
     *
     * @param  string $data_request_id data_request_id (required)
     * @param  \DocSpring\Model\UpdateSubmissionDataRequestData $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDataRequest'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\CreateSubmissionDataRequestResponse|\DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse
     */
    public function updateDataRequest($data_request_id, $data, string $contentType = self::contentTypes['updateDataRequest'][0])
    {
        list($response) = $this->updateDataRequestWithHttpInfo($data_request_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation updateDataRequestWithHttpInfo
     *
     * Update a submission data request
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\UpdateSubmissionDataRequestData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDataRequest'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\CreateSubmissionDataRequestResponse|\DocSpring\Model\MultipleErrorsResponse|\DocSpring\Model\ErrorResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDataRequestWithHttpInfo($data_request_id, $data, string $contentType = self::contentTypes['updateDataRequest'][0])
    {
        $request = $this->updateDataRequestRequest($data_request_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\CreateSubmissionDataRequestResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\CreateSubmissionDataRequestResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\CreateSubmissionDataRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\MultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateDataRequestAsync
     *
     * Update a submission data request
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\UpdateSubmissionDataRequestData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDataRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDataRequestAsync($data_request_id, $data, string $contentType = self::contentTypes['updateDataRequest'][0])
    {
        return $this->updateDataRequestAsyncWithHttpInfo($data_request_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDataRequestAsyncWithHttpInfo
     *
     * Update a submission data request
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\UpdateSubmissionDataRequestData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDataRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDataRequestAsyncWithHttpInfo($data_request_id, $data, string $contentType = self::contentTypes['updateDataRequest'][0])
    {
        $returnType = '\DocSpring\Model\CreateSubmissionDataRequestResponse';
        $request = $this->updateDataRequestRequest($data_request_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDataRequest'
     *
     * @param  string $data_request_id (required)
     * @param  \DocSpring\Model\UpdateSubmissionDataRequestData $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDataRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDataRequestRequest($data_request_id, $data, string $contentType = self::contentTypes['updateDataRequest'][0])
    {

        // verify the required parameter 'data_request_id' is set
        if ($data_request_id === null || (is_array($data_request_id) && count($data_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data_request_id when calling updateDataRequest'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateDataRequest'
            );
        }


        $resourcePath = '/data_requests/{data_request_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($data_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'data_request_id' . '}',
                ObjectSerializer::toPathValue($data_request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTemplate
     *
     * Update a Template
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\UpdateHtmlTemplate $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SuccessMultipleErrorsResponse
     */
    public function updateTemplate($template_id, $data, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        list($response) = $this->updateTemplateWithHttpInfo($template_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation updateTemplateWithHttpInfo
     *
     * Update a Template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SuccessMultipleErrorsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTemplateWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        $request = $this->updateTemplateRequest($template_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SuccessMultipleErrorsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTemplateAsync
     *
     * Update a Template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsync($template_id, $data, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        return $this->updateTemplateAsyncWithHttpInfo($template_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTemplateAsyncWithHttpInfo
     *
     * Update a Template
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsyncWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        $returnType = '\DocSpring\Model\SuccessMultipleErrorsResponse';
        $request = $this->updateTemplateRequest($template_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTemplate'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdateHtmlTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTemplateRequest($template_id, $data, string $contentType = self::contentTypes['updateTemplate'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling updateTemplate'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateTemplate'
            );
        }


        $resourcePath = '/templates/{template_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTemplateDocument
     *
     * Update a template&#39;s document with a form POST file upload
     *
     * @param  string $template_id template_id (required)
     * @param  \SplFileObject $template_document template_document (required)
     * @param  string|null $template_name template_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocument'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse
     */
    public function updateTemplateDocument($template_id, $template_document, $template_name = null, string $contentType = self::contentTypes['updateTemplateDocument'][0])
    {
        list($response) = $this->updateTemplateDocumentWithHttpInfo($template_id, $template_document, $template_name, $contentType);
        return $response;
    }

    /**
     * Operation updateTemplateDocumentWithHttpInfo
     *
     * Update a template&#39;s document with a form POST file upload
     *
     * @param  string $template_id (required)
     * @param  \SplFileObject $template_document (required)
     * @param  string|null $template_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocument'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTemplateDocumentWithHttpInfo($template_id, $template_document, $template_name = null, string $contentType = self::contentTypes['updateTemplateDocument'][0])
    {
        $request = $this->updateTemplateDocumentRequest($template_id, $template_document, $template_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SuccessMultipleErrorsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTemplateDocumentAsync
     *
     * Update a template&#39;s document with a form POST file upload
     *
     * @param  string $template_id (required)
     * @param  \SplFileObject $template_document (required)
     * @param  string|null $template_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateDocumentAsync($template_id, $template_document, $template_name = null, string $contentType = self::contentTypes['updateTemplateDocument'][0])
    {
        return $this->updateTemplateDocumentAsyncWithHttpInfo($template_id, $template_document, $template_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTemplateDocumentAsyncWithHttpInfo
     *
     * Update a template&#39;s document with a form POST file upload
     *
     * @param  string $template_id (required)
     * @param  \SplFileObject $template_document (required)
     * @param  string|null $template_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateDocumentAsyncWithHttpInfo($template_id, $template_document, $template_name = null, string $contentType = self::contentTypes['updateTemplateDocument'][0])
    {
        $returnType = '\DocSpring\Model\SuccessMultipleErrorsResponse';
        $request = $this->updateTemplateDocumentRequest($template_id, $template_document, $template_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTemplateDocument'
     *
     * @param  string $template_id (required)
     * @param  \SplFileObject $template_document (required)
     * @param  string|null $template_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTemplateDocumentRequest($template_id, $template_document, $template_name = null, string $contentType = self::contentTypes['updateTemplateDocument'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling updateTemplateDocument'
            );
        }

        // verify the required parameter 'template_document' is set
        if ($template_document === null || (is_array($template_document) && count($template_document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_document when calling updateTemplateDocument'
            );
        }



        $resourcePath = '/templates/{template_id}?endpoint_variant=update_template_pdf_with_form_post';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }

// Manually build multipart with bracketed keys and filename for proper Rack upload handling
$multipart = true;
$headers = $this->headerSelector->selectHeaders(
    ['application/json', ],
    $contentType,
    $multipart
);

$multipartContents = [];
// template[document]
if ($template_document instanceof \SplFileObject) {
    $path = $template_document->getRealPath();
    $filename = basename($path);
    $stream = \GuzzleHttp\Psr7\Utils::tryFopen($path, 'rb');
    $multipartContents[] = [
        'name' => 'template[document]',
        'contents' => $stream,
        'filename' => $filename,
    ];
} else {
    // Fallback: send as-is
    $multipartContents[] = [
        'name' => 'template[document]',
        'contents' => $template_document,
    ];
}
// template[name]
if ($template_name !== null) {
    $multipartContents[] = [
        'name' => 'template[name]',
        'contents' => $template_name,
    ];
}

// Build multipart body
$httpBody = new \GuzzleHttp\Psr7\MultipartStream($multipartContents);


        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTemplateDocumentFromUpload
     *
     * Update a template&#39;s document with a cached S3 file upload
     *
     * @param  string $template_id template_id (required)
     * @param  \DocSpring\Model\UpdatePdfTemplate $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocumentFromUpload'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse
     */
    public function updateTemplateDocumentFromUpload($template_id, $data, string $contentType = self::contentTypes['updateTemplateDocumentFromUpload'][0])
    {
        list($response) = $this->updateTemplateDocumentFromUploadWithHttpInfo($template_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation updateTemplateDocumentFromUploadWithHttpInfo
     *
     * Update a template&#39;s document with a cached S3 file upload
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocumentFromUpload'] to see the possible values for this operation
     *
     * @throws \DocSpring\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \DocSpring\Model\SuccessMultipleErrorsResponse|\DocSpring\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTemplateDocumentFromUploadWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['updateTemplateDocumentFromUpload'][0])
    {
        $request = $this->updateTemplateDocumentFromUploadRequest($template_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\DocSpring\Model\ErrorResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\DocSpring\Model\SuccessMultipleErrorsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\SuccessMultipleErrorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DocSpring\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateTemplateDocumentFromUploadAsync
     *
     * Update a template&#39;s document with a cached S3 file upload
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocumentFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateDocumentFromUploadAsync($template_id, $data, string $contentType = self::contentTypes['updateTemplateDocumentFromUpload'][0])
    {
        return $this->updateTemplateDocumentFromUploadAsyncWithHttpInfo($template_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTemplateDocumentFromUploadAsyncWithHttpInfo
     *
     * Update a template&#39;s document with a cached S3 file upload
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocumentFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateDocumentFromUploadAsyncWithHttpInfo($template_id, $data, string $contentType = self::contentTypes['updateTemplateDocumentFromUpload'][0])
    {
        $returnType = '\DocSpring\Model\SuccessMultipleErrorsResponse';
        $request = $this->updateTemplateDocumentFromUploadRequest($template_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTemplateDocumentFromUpload'
     *
     * @param  string $template_id (required)
     * @param  \DocSpring\Model\UpdatePdfTemplate $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplateDocumentFromUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTemplateDocumentFromUploadRequest($template_id, $data, string $contentType = self::contentTypes['updateTemplateDocumentFromUpload'][0])
    {

        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling updateTemplateDocumentFromUpload'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateTemplateDocumentFromUpload'
            );
        }


        $resourcePath = '/templates/{template_id}?endpoint_variant=update_template_pdf_with_cached_upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($data)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($data));
            } else {
                $httpBody = $data;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
